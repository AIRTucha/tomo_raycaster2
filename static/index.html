<html lang="en">
	<head>
		<title>Lidar - WebGL Volume Rendering</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #000000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #ffffff;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {
				color: #ffffff;
			}

			#oldie a { color:#da0 }
		</style>
	</head>
	<body>
		<div id="container">
			<div>Transfer function</div>
			5.0<img id="transferFunctionImg" style="align:right"/>-5.0
		</div>
		<script src="./js/three.js"></script>
		<script src="./js/GeometryHelper.js"></script>
		<script src="./js/Detector.js"></script>
		<script src="./js/stats.min.js"></script>
		<script src="./js/OrbitControls.js"></script>
		<script src="./js/dat.gui.min.js"></script>

		<script id="vertexShaderFirstPass" type="x-shader/x-vertex">
			// varying vec3 worldSpaceCoords;
			
			// void main()
			// {
			// 	//Set the world space coordinates of the back faces vertices as output.
			// 	worldSpaceCoords = position + vec3(0.5, 0.5, 0.5); //move it from [-0.5;0.5] to [0,1]
			// 	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			// }
			#ifdef GL_ES
			precision highp float;
			#endif

			attribute vec4 vertColor;

			varying vec4 backColor;
			varying vec4 pos;

			void main(void)
			{
				// backColor = vec4(position, 1.0);
				backColor = vertColor;

				pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				gl_Position = pos;
			}

		</script>
		<script id="fragmentShaderFirstPass" type="x-shader/x-fragment">
			// varying vec3 worldSpaceCoords;

			// void main()
			// {
			// 	//The fragment's world space coordinates as fragment output.
			// 	gl_FragColor = vec4( worldSpaceCoords.x , worldSpaceCoords.y, worldSpaceCoords.z, 1 );
			// }

			#ifdef GL_ES
			precision highp float;
			#endif

			varying vec4 backColor;
			varying vec4 pos;

			void main(void)
			{
				gl_FragColor = backColor;
			}

		</script>

		<script id="vertexShaderSecondPass" type="x-shader/x-vertex">
			// varying vec3 worldSpaceCoords;
			// varying vec4 projectedCoords;
			
			// void main()
			// {
			// 	worldSpaceCoords = (modelMatrix * vec4(position + vec3(0.5, 0.5,0.5), 1.0 )).xyz;
			// 	gl_Position = projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );
			// 	projectedCoords =  projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			// }

			// attribute vec3 aVertexPosition;
			// attribute vec4 aVertexColor;

			// uniform mat4 uMVMatrix;
			// uniform mat4 uPMatrix;

			#ifdef GL_ES
			precision highp float;
			#endif
			
			attribute vec4 vertColor;

			varying vec4 frontColor;
			varying vec4 pos;

			void main(void)
			{
				frontColor = vertColor;

				pos = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				gl_Position = pos;
			}


		</script>
		<script id="fragmentShaderSecondPass" type="x-shader/x-fragment">

			#ifdef GL_ES
			precision highp float;
			#endif

			varying vec4 frontColor;
			varying vec4 pos;

			uniform sampler2D uBackCoord;
			uniform sampler2D uVolData;
			uniform sampler2D uTransferFunction;

			// uniform sampler2D tex, cubeTex, transferTex;
			// uniform float steps;
			// uniform float alphaCorrection;
			// uniform float numberOfSlices;
			// uniform float row;
			// uniform float col;

			// uniform sampler2D uBackCoord;
			// uniform sampler2D uVolData;
			// uniform sampler2D uTransferFunction;

			uniform float uNumberOfSlices;
			uniform float uMinGrayVal;
			uniform float uMaxGrayVal;
			uniform float uOpacityVal;
			uniform float uColorVal;
			uniform float uSlicesOverX;
			uniform float uSlicesOverY;
			uniform float uSteps;

			// float uNumberOfSlices = 255.0;
			// float uMinGray = 0.0;
			// float uMaxGray = 1.0;
			// float uOpacityVal = 1.0;
			// float uColorVal = 0.0;
			// float uSlicesOverX = 16.0;
			// float uSlicesOverY = 16.0;
			// float uSteps = 256.0;

			// const float steps = 195.0;

			//Acts like a texture3D using Z slices and trilinear filtering.

			float getVolumeValue(vec3 volpos)
			{
				float s1,s2;
				float dx1,dy1;
				float dx2,dy2;

				vec2 texpos1,texpos2;

				s1 = floor(volpos.z*uNumberOfSlices);
				// s2 = s1+1.0;

				volpos.xy /= 16.0;

				// dx1 = fract(s1/uSlicesOverX);
				// dy1 = volpos.y/uSlicesOverY;
				// dy1 = floor(volpos.z/uSlicesOverY)/uSlicesOverY;

				// dx2 = fract(s2/uSlicesOverX);
				// dy2 = floor(s2/uSlicesOverY)/uSlicesOverY;
				
				texpos1.x = fract(s1/uSlicesOverX)+volpos.x;
				texpos1.y = floor(s1/uSlicesOverX)/uSlicesOverY+volpos.y;

				// texpos2.x = dx2+(volpos.x/uSlicesOverX);
				// texpos2.y = dy2+(volpos.y/uSlicesOverY);

				// return mix( texture2D(uVolData,texpos1).x, texture2D(uVolData,texpos2).x, (volpos.z*uNumberOfSlices)-s1);
				return texture2D(uVolData,texpos1).x;
			}

			void main(void)
			{

				// uBackCoord = tex;
				// uVolData = cubeTex;
				// uTransferFunction = transferTex;

				vec2 texC = ((pos.xy/pos.w) + 1.0) / 2.0;
				// vec2 texC = pos.xy/pos.w;
				// texC.x = 0.5*texC.x + 0.5;
				// texC.y = 0.5*texC.y + 0.5;

				vec4 backColor = texture2D(uBackCoord,texC);

				vec3 dir = backColor.rgb - frontColor.rgb;
				vec4 vpos = frontColor;
			  
			  	float cont = 0.0;

				vec3 Step = dir/uSteps;

				vec4 accum = vec4(0, 0, 0, 0);
				vec4 sample = vec4(0.0, 0.0, 0.0, 0.0);
			 	vec4 value = vec4(0, 0, 0, 0);

				// float opacityFactor = 70.0;
				float opacityFactor = uOpacityVal;
				float lightFactor = uColorVal;
				float v = 0.0;
				//// const 999 - only how example big number
				//// It because expression i < uSteps impossible
				for(float i = 0.0; i < 4095.0; i+=1.0)
				{
				//It because expression i < uSteps impossible
					if(i == uSteps) {
						break;
					}

					// vec2 tf_pos;
					// tf_pos.x = getVolumeValue(vpos.xyz);
					// tf_pos.y = 0.5;
					
					// value = texture2D(uTransferFunction,tf_pos);
					// value = sampleAs3DTexture_(vec3(vpos.xy, 0.0));
					// value = vpos;
					// value = vec4(tf_pos.x);
					// value = sampleAs3DTexture(vpos.xyz);
					// value = vpos;


					// if(vpos.z > uSteps/512.0) {
					// 	value = vec4(0.3);
					// } else {
						// if(vpos.x>=8.0*(1.0/16.0) && vpos.x<=9.0*(1.0/16.0))
						// if(vpos.y>=11.0*(1.0/16.0) && vpos.y<=12.0*(1.0/16.0))
						// if(vpos.z>=0.0 && vpos.z<=1.0)
							// gl_FragColor = vec4(vpos.xyz, 1.0);

						// value = vec4(texture2D(uVolData, vpos.xy));
						// vpos.xy*=16.0;
						v = getVolumeValue(vpos.xyz);
						vec2 tf_pos;
						tf_pos.x = v;
						tf_pos.y = 0.5;
						
						value = texture2D(uTransferFunction,tf_pos);

					// }

					if(value.x < uMinGrayVal || value.x > uMaxGrayVal || value.a < 0.15) {
						value = vec4(0.0);
					}


					// // Process the volume sample
					// // sample = value * opacityFactor;
					// // sample.rgb = value.rgb * lightFactor;
					value.a *= uOpacityVal;
					value.grb *= uColorVal;
					accum += value;
					// accum.a += sample.a;

					// //advance the current position
					vpos.xyz += Step;

					// //break if the position is greater than <1, 1, 1>
					if(accum.a>=0.9)
						break;

				}



			
				// gl_FragColor = vec4(vpos.xy, 0.0, 1.0);
				gl_FragColor = accum;
				// gl_FragColor = vec4(0.8, 0.8, 0.8, 1.0);
				// gl_FragColor = texture2D( uVolData, vpos.xy );

			}
		</script>
				
		<script>
			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var container, stats;
			var camera, sceneFirstPass, sceneSecondPass, renderer;

			var clock = new THREE.Clock();
			var rtTexture, transferTexture;
			//var cubeTextures = ['bonsai', 'foot', 'teapot', 'lidar'];
            var cubeTextures = ['bonsaiResultAntialias.png', 'bonsaiResultBicubic.png', 'bonsaiResultBilinear.png', 'bonsaiResultNearest.png', 'slice_map.jpg', 'bonsai', 'foot', 'teapot', 'slicemap_99992_2.png', 'lidar.raw.png', 'lidar.raw-6.png', 'lidar.raw-8.png'];

			var histogram = [];
			var guiControls;
			
			var materialSecondPass;
            init();
			animate();

			function init() {

				//Parameters that can be modified.
				guiControls = new function() {
					this.model = 'Raw';
					this.steps = 256.0;
					this.numberOfSlices = 255.0;
					this.slicesOverX = 16.0;
					this.slicesOverY = 16.0;
					this.opacityVal = 1.0;
					this.colorVal = 1.0;
					this.minGrayVal = 0.01;
					this.maxGrayVal = 0.99;

					this.xLeft = 0.01;
					this.xRigth = 0.99;

					this.yLeft = 0.01;
					this.yRigth = 0.99;

					this.zLeft = 0.01;
					this.zRigth = 0.99;

					this.color1 = "#00007F";
					this.stepPos1 = 0.0;
					this.color2 = "#0080FF";
					this.stepPos2 = 0.25;
					this.color3 = "#7CFF79";
					this.stepPos3 = 0.5;
					this.color4 = "#FF9400";
					this.stepPos4 = 0.75;
					this.color5 = "#7F0000";
					this.stepPos5 = 1.0;
					// this.color1 = "#7F0000";
					// this.stepPos1 = 0.0;
					// this.color2 = "#FF9400";
					// this.stepPos2 = 0.25;
					// this.color3 = "#7CFF79";
					// this.stepPos3 = 0.5;
					// this.color4 = "#0080FF";
					// this.stepPos4 = 0.75;
					// this.color5 = "#00007F";
					// this.stepPos5 = 1.0;
				};
				
				container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 45, 1.0, 0.01, 10.0 );

				camera.position.z = 1.2;
				camera.position.y = 0.0;
				camera.position.x = 0.0;
				camera.up.y = -1;

				// camera.rotation.z = 180;

				controls = new THREE.OrbitControls( camera, container );
				controls.center.set( 0.0, 0.0, 0.0 );

				//Load the 2D texture containing the Z slices.
				cubeTextures['bonsaiResultAntialias.png'] = THREE.ImageUtils.loadTexture('bonsaiResultAntialias.png');
				cubeTextures['bonsaiResultAntialias.png'].flipY = false;

				cubeTextures['bonsaiResultBicubic.png'] = THREE.ImageUtils.loadTexture('bonsaiResultBicubic.png');
				cubeTextures['bonsaiResultBicubic.png'].flipY = false;

				cubeTextures['bonsaiResultBilinear.png'] = THREE.ImageUtils.loadTexture('bonsaiResultBilinear.png');
				cubeTextures['bonsaiResultBilinear.png'].flipY = false;

				cubeTextures['bonsaiResultNearest.png'] = THREE.ImageUtils.loadTexture('bonsaiResultNearest.png');
				cubeTextures['bonsaiResultNearest.png'].flipY = false;
				
				cubeTextures['bonsai'] = THREE.ImageUtils.loadTexture('bonsai.raw.png');
				cubeTextures['bonsai'].flipY = false;
				
				cubeTextures['teapot'] = THREE.ImageUtils.loadTexture('teapot.raw.png');
				cubeTextures['teapot'].flipY = false;
				
				cubeTextures['foot'] = THREE.ImageUtils.loadTexture('foot.raw.png');
				cubeTextures['foot'].flipY = false;

				cubeTextures['slicemap_99992_2.png'] = THREE.ImageUtils.loadTexture('slicemap_99992_2.png');
				cubeTextures['slicemap_99992_2.png'].flipY = false;

				cubeTextures['lidar.raw.png'] = THREE.ImageUtils.loadTexture('lidar.raw.png');
				cubeTextures['lidar.raw.png'].flipY = false;

                cubeTextures['lidar.raw-6.png'] = THREE.ImageUtils.loadTexture('lidar.raw-6.png');
                cubeTextures['lidar.raw-6.png'].flipY = false;

                cubeTextures['lidar.raw-.png'] = THREE.ImageUtils.loadTexture('lidar.raw-8.png');
                cubeTextures['lidar.raw-.png'].flipY = false;

				var transferTexture = updateTransferFunction();
			
				var screenSize = new THREE.Vector2( 512.0, 512.0 );
				rtTexture = new THREE.WebGLRenderTarget( screenSize.x, screenSize.y, { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBAFormat} );

				rtTexture.wrapS = rtTexture.wrapT = THREE.ClampToEdgeWrapping;
				
				var materialFirstPass = new THREE.ShaderMaterial( {
					vertexShader: document.getElementById( 'vertexShaderFirstPass' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShaderFirstPass' ).textContent,
					attributes: {
						vertColor: {type: 'c', value: [] }
					},
					side: THREE.FrontSide,
					transparent: true
				} );
				
				materialSecondPass = new THREE.ShaderMaterial( {
					vertexShader: document.getElementById( 'vertexShaderSecondPass' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShaderSecondPass' ).textContent,
					side: THREE.BackSide,
					attributes: {
						vertColor: {type: 'c', value: [] }
					},
					uniforms: {
						// tex:             { type: "t",  value: rtTexture }, 
						// cubeTex:         { type: "t",  value: cubeTextures['Raw'] }, 
						// transferTex:     { type: "t",  value: transferTexture },
						uBackCoord:       { type: "t",  value: rtTexture }, 
						uVolData:         { type: "t",  value: cubeTextures['Raw'] }, 
						uTransferFunction:{ type: "t",  value: transferTexture },

						uSteps:    		  { type: "1f", value: guiControls.steps },
						uNumberOfSlices:  { type: "1f", value: guiControls.numberOfSlices },
						uSlicesOverX:     { type: "1f", value: guiControls.slicesOverX },
						uSlicesOverY:     { type: "1f", value: guiControls.slicesOverY },
						uOpacityVal:      { type: "1f", value: guiControls.opacityVal },
						uColorVal:        { type: "1f", value: guiControls.colorVal },
						uMinGrayVal:      { type: "1f", value: guiControls.minGrayVal },
						uMaxGrayVal:      { type: "1f", value: guiControls.maxGrayVal }
					},
					transparent: true
				 });

				sceneFirstPass = new THREE.Scene();
				sceneSecondPass = new THREE.Scene();

				var originalDimension = new GeometryDimension();

				var geometryHelper = new GeometryHelper();
				geometry = geometryHelper.createBoxGeometry(originalDimension);
				geometry.applyMatrix( new THREE.Matrix4().makeTranslation( -0.5, -0.5, -0.5 ) );

				// var boxGeometry = new THREE.BoxGeometry(1.0, 1.0, 1.0);
				// boxGeometry = geometry;
				// boxGeometry.doubleSided = true;
				
				meshFirstPass = new THREE.Mesh( geometry, materialFirstPass );
				meshSecondPass = new THREE.Mesh( geometry, materialSecondPass );
						
				sceneFirstPass.add( meshFirstPass );
				sceneSecondPass.add( meshSecondPass );
				
				renderer = new THREE.WebGLRenderer();

				container.appendChild( renderer.domElement );

				// renderer.domElement.style.width = '100%';
				// renderer.domElement.style.height = '100%';

				renderer.setSize(512, 512);
				renderer.setClearColor(0xa0a0a0);

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				
				var gui = new dat.GUI();
				//var modelSelected = gui.add(guiControls, 'model', [ 'bonsai', 'foot', 'teapot', 'lidar'] );
				var modelSelected = gui.add(guiControls, 'model', ['bonsaiResultAntialias.png', 'bonsaiResultBicubic.png', 'bonsaiResultBilinear.png', 'bonsaiResultNearest.png', 'slice_map.jpg', 'bonsai', 'foot', 'teapot', 'slicemap_99992_2.png', 'lidar.raw.png', 'lidar.raw-6.png', 'lidar.raw-8.png'] );
				gui.add(guiControls, 'steps', 0.0, 512.0);
				gui.add(guiControls, 'numberOfSlices', 1, 500).step(1.0);
				gui.add(guiControls, 'slicesOverX', 1, 23).step(1.0);
				gui.add(guiControls, 'slicesOverY', 1, 23).step(1.0);
				gui.add(guiControls, 'opacityVal', 0.0, 1.0).step(0.001);
				gui.add(guiControls, 'colorVal', 0.0, 1.0).step(0.001);
				gui.add(guiControls, 'minGrayVal', 0.0, 1.0).step(0.01);
				gui.add(guiControls, 'maxGrayVal', 0.0, 1.0).step(0.01);

				// var xLeft = gui.add(guiControls, 'xLeft', 0.0, 1.0).step(0.01);
				// var xRight = gui.add(guiControls, 'xRigth', 0.0, 1.0).step(0.01);
				
				// gui.add(guiControls, 'yLeft', 0.0, 1.0).step(0.01);
				// gui.add(guiControls, 'yRigth', 0.0, 1.0).step(0.01);
				
				// gui.add(guiControls, 'zLeft', 0.0, 1.0).step(0.01);
				// gui.add(guiControls, 'zRigth', 0.0, 1.0).step(0.01);
								
				
				// xLeft.onChange(
				// 	function(value) {
				// 		var originalDimension = new GeometryDimension();

				// 		originalDimension.xmin = value;

				// 		var geometryHelper = new GeometryHelper();
				// 		geometry = geometryHelper.createBoxGeometry(originalDimension);
				// 		geometry.applyMatrix( new THREE.Matrix4().makeTranslation( -0.5, -0.5, -0.5 ) );
				// 	}
				// );

				modelSelected.onChange(function(value) { materialSecondPass.uniforms.uVolData.value =  cubeTextures[value]; } );				
				
				//Setup transfer function steps.
				var step1Folder = gui.addFolder('Step 1');
				var controllerColor1 = step1Folder.addColor(guiControls, 'color1');
				var controllerStepPos1 = step1Folder.add(guiControls, 'stepPos1', 0.0, 1.0);
				controllerColor1.onChange(updateTextures);
				controllerStepPos1.onChange(updateTextures);
				
				var step2Folder = gui.addFolder('Step 2');
				var controllerColor2 = step2Folder.addColor(guiControls, 'color2');
				var controllerStepPos2 = step2Folder.add(guiControls, 'stepPos2', 0.0, 1.0);
				controllerColor2.onChange(updateTextures);
				controllerStepPos2.onChange(updateTextures);
				
				var step3Folder = gui.addFolder('Step 3');
				var controllerColor3 = step3Folder.addColor(guiControls, 'color3');
				var controllerStepPos3 = step3Folder.add(guiControls, 'stepPos3', 0.0, 1.0);
				controllerColor3.onChange(updateTextures);
				controllerStepPos3.onChange(updateTextures);
						
				var step4Folder = gui.addFolder('Step 4');
				var controllerColor4 = step4Folder.addColor(guiControls, 'color4');
				var controllerStepPos4 = step4Folder.add(guiControls, 'stepPos4', 0.0, 1.0);
				controllerColor4.onChange(updateTextures);
                controllerStepPos4.onChange(updateTextures);

				var step5Folder = gui.addFolder('Step 5');
				var controllerColor5 = step5Folder.addColor(guiControls, 'color5');
				var controllerStepPos5 = step5Folder.add(guiControls, 'stepPos5', 0.0, 1.0);
				controllerColor5.onChange(updateTextures);
				controllerStepPos5.onChange(updateTextures);

				step1Folder.open();
				step2Folder.open();
				step3Folder.open();
				step4Folder.open();
				step5Folder.open();

				onWindowResize();

				window.addEventListener( 'resize', onWindowResize, false );

			}
			
			function updateTextures(value)
			{
				materialSecondPass.uniforms.uTransferFunction.value = updateTransferFunction();
			}
			function updateTransferFunction()
			{
				var canvas = document.createElement('canvas');
				canvas.height = 20;
				canvas.width = 255;

				var ctx = canvas.getContext('2d');
			
				var grd = ctx.createLinearGradient(0, 0, canvas.width -1 , canvas.height - 1);
				grd.addColorStop(guiControls.stepPos1, guiControls.color1);   
				grd.addColorStop(guiControls.stepPos2, guiControls.color2);  
				grd.addColorStop(guiControls.stepPos3, guiControls.color3);  
				grd.addColorStop(guiControls.stepPos4, guiControls.color4);  
				grd.addColorStop(guiControls.stepPos5, guiControls.color5);  
				
				ctx.fillStyle = grd;
				ctx.fillRect(0,0,canvas.width ,canvas.height );
				
				var img = document.getElementById("transferFunctionImg");
				img.src = canvas.toDataURL();
				img.style.width = "255 px";
				img.style.height = "2 px";
				
				transferTexture =  new THREE.Texture(canvas);
				transferTexture.wrapS = transferTexture.wrapT =  THREE.ClampToEdgeWrapping;
				transferTexture.needsUpdate = true;

				return transferTexture;
			}
			
			function onWindowResize( event ) {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );
			}

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();
			}

			function render() {

				var delta = clock.getDelta();

				//Render first pass and store the world space coords of the back face fragments into the texture.
				renderer.render( sceneFirstPass, camera, rtTexture, true );
				// renderer.render( sceneFirstPass, camera);

				// materialSecondPass.uniforms.uBackCoord.value = rtTexture;

				materialSecondPass.uniforms.uSteps.value = guiControls.steps;
				materialSecondPass.uniforms.uNumberOfSlices.value = guiControls.numberOfSlices;
				materialSecondPass.uniforms.uSlicesOverX.value = guiControls.slicesOverX;
				materialSecondPass.uniforms.uSlicesOverY.value = guiControls.slicesOverY;
				materialSecondPass.uniforms.uOpacityVal.value = guiControls.opacityVal;
				materialSecondPass.uniforms.uColorVal.value = guiControls.colorVal;
				materialSecondPass.uniforms.uMinGrayVal.value = guiControls.minGrayVal;
				materialSecondPass.uniforms.uMaxGrayVal.value = guiControls.maxGrayVal;

				//Render the second pass and perform the volume rendering.
				renderer.render( sceneSecondPass, camera );
				
            }   

			//Leandro Barbagallo - lebarba at gmail.com
		</script>

	</body>
</html>
